# Static关键字的作用

### 1.全局静态变量

全局变量前加上关键字static。在整个程序的运行期间一直存在。

内存中的位置：静态存储区

初始化：如果不初始化会自动存为0

作用域：**在声明他的文件之外是不可见的，只在本文件中。**

>静态全局变量和全局变量的区别
>
>全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。**这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。**由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。

```c++

#include<iostream>
using namespace std;

class test
{
public:
	int a;
	int* b;
	static int c;

	void hello()
	{
		cout << "hello";
	}
	test() {

	}
	~test()
	{

	}
};

int main()
{
	cout << sizeof(test);
	getchar();
	return 0;
}

```

**答案是8**，因为静态变量c存储在静态存储区中。

### 2.局部静态变量

在局部变量前加上static， 函数就定义为局部静态变量。

内存中的位置：静态存储区

初始化：没有初始化的默认为0

作用域：作用域仍是局部作用域，定义它的函数或者语句结束的时候，作用域结束。但是局部静态变量并不销毁，仍在内存中，但是不能访问，只到函数再次被调用，且值不变。



## 3.静态函数

在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，**但静态函数只是在声明他的文件当中可见，不能被其他文件所用。**

函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；

warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；



### 4.类的静态成员

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用



### 5.类的静态函数

静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。

在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);



### 6.static的作用

对于函数定义和代码块之外的变量声明，static修改标识符的链接属性，由默认的external变为internal，作用域和存储类型不改变，这些符号只能在声明它们的源文件中访问。

对于代码块内部的变量声明，static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。这种变量在程序执行之前就创建，在程序执行的整个周期都存在。

对于被static修饰的普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用

对于被static修饰的类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过<类名>::<静态成员>来使用。











