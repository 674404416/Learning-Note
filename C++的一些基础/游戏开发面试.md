# 游戏开发面试知识

## 1.c++基础知识

### 1.c++引用和指针区别

- 不存在空引用。引用必须连接到一块合法的内存。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。（引用不能改变地址）
- 引用必须在创建时被初始化。指针可以在任何时间被初始化。



#### 2.c++面向对象的特性

- **多态** ： 一个东西对于不同情况下体现出的不同状态

  - 重载和重写： 重载是有参数不同，重写必须相同
  - 虚函数 ： 要用virtual声明
    - **虚函数** ：是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。
    - 纯虚函数：**需要在基类中定义，但是又不在基类中实现。**virtual int area() = 0;
  - 静态链接和动态链接
    - 静态链接：在编译器编译的时候就连接好的事情
    - 动态链接：在调用的时候连接的事情

- **继承** ：一个类可以继承自多个类，也可以派生多个类

  - 访问修饰符： **public、protected** 或 **private** 。如果未设置就是private。

  - public什么类都可以访问，protected必须是子类或者同一类，private只能自己访问。

  - | 访问     | public | protected | private |
    | :------- | :----- | :-------- | :------ |
    | 同一个类 | yes    | yes       | yes     |
    | 派生类   | yes    | yes       | no      |
    | 外部的类 | yes    | no        | no      |

  

- **封装**：将数据设置成私有的，通过公有的函数来进行对类成员的修改。用户不需要了解它，但它又是类能正常工作所必需的。

  - C++中**, 虚函数**可以为private, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的private虚函数。虚函数的重载性和它声明的权限无关。

    

- **抽象**：数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。

  - 优点
    - 类的内部受到保护，不会因无意的用户级错误导致对象状态受损。
    - 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。



#### 3.虚函数表

虚函数的地址存放在虚函数表中，多态是通过虚函数和虚函数表实现的。

详解：https://blog.csdn.net/u012630961/article/details/81226351



#### 4.虚函数和纯虚函数的区别

1. 虚函数是有实现的，纯虚函数没有实现（virtual int area() = 0;）。
2. 虚函数在子类里可以不重载，但是纯虚函数必须重载。
3. 带纯虚函数的类叫抽象类，抽象类不能生成对象。必须纯虚函数重载之后才可以生成对象。



#### 5.虚析构函数的作用

防止内存泄露

具体：https://blog.csdn.net/derkampf/article/details/62093252



#### 6.static和const的区别

static表示是静态的，在函数执行完之后不会释放空间，下次调用还是上次的值。

- static不能在类中初始化，类中只是声明，需要在类的外部初始化。

const在函数执行完之后会释放空间。是一个恒定的**常量。**不能修改。

```c++
class Test
{
public:
	Test() {};
	const int a=1;
	static int b;
	int c = 3;
};
int Test::b = 1;//static初始化
```



#### 7.STL中的Vector、Map、Set底层原理

> 内容来自https://blog.csdn.net/tommyzht/article/details/47312591

1、Vector是顺序容器，是一个动态数组，支持随机存取、插入、删除、查找等操作，在内存中是一块连续的空间。在原有空间不够情况下自动分配空间，增加为原来的两倍。vector随机存取效率高，但是在vector插入元素，需要移动的数目多，效率低下。

注意：**vector动态增加大小时，并不是在原空间之后持续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，**然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。



2、Map是关联容器，以键值对的形式进行存储，方便进行查找。关键词起到索引的作用，值则表示与索引相关联的数据。以**红黑树**的结构实现，插入删除等操作都在O(logn)时间内完成。

注意：map的下标操作，其行为与vector很不相同：使用一个不在容器中关键字作为下标，会添加一个具有此关键字的元素到map中。一般使用find函数代替下标操作。

3、Set是关联容器，set中每个元素只包含一个关键字。set支持高效的关键字查询操作——检查一个给定的关键字是否在set中。set也是以**红黑树**的结构实现，支持高效插入、删除等操作。



#### 8.map中为何使用红黑树而不是二叉平衡树？

- 红黑树在重新平衡上效率比二叉平衡树高



#### 9.B树和B+树的区别

B树：每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为null。

B+树：只有叶子节点存储data，叶子节点包含了这棵树的所有键值，叶子节点不存储指针。



#### 10.**new/delete与malloc/free的区别**

- new是运算符，malloc是C语言库函数
- new可以重载，malloc不能重载
- new的变量是数据类型，malloc的是字节大小
- new可以调用构造函数，delete可以调用析构函数，malloc/free不能
- new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化
- malloc分配的内存不够的时候可以使用realloc扩容，new没有这样的操作
- new内存分配失败抛出bad_malloc，malloc内存分配失败返回NULL值



## 2.多线程

#### 1.wait和sleep的区别









## 3.网络编程

> 1、TCP的四次挥手
> 2、四次挥手中，TIME-WAIT状态是在哪一步？
> 3、TIME-WAIT()状态下的等待时间是多少？（2*MSL）为何是2*MSL?
> 4、TCP中的流量控制原理
> 5、TCP的拥塞控制原理及实现拥塞控制的主要算法有哪些？（我只说了慢启动，面试官说有四种：①慢启动；②拥塞避免；③快重传；④快恢复）

#### 1.网络的七层\五层结构

![体系结构](http://img.blog.csdn.net/20170822222325781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2lsZW5jZU9P/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



#### 2.TCP的四次握手

来自https://blog.csdn.net/qq_38950316/article/details/81087809



**三次握手**：第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

![img](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



**四次握手:**

1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

![img](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



#### 3.TIME-WAIT()状态下的等待时间是多少？

​		2MSL 是最长报文段寿命

#### 4、TCP中的流量控制和拥塞控制



#### 5.TCP的拥塞控制原理及实现拥塞控制的主要算法有哪些？

①慢开始；②拥塞避免；③快重传；④快恢复

```
1、慢开始和拥塞避免
基于窗口的拥塞控制，在发送方维护一个拥塞窗口（cwnd），大小等于发送窗口，通过出现了超时来判断网络出现拥塞。慢开始的思路是一开始发送方发送一个字节，在收到接收方的确认，然后发送的字节数量增大一倍（也就是按照指数增长的速率），从小到大逐步增大cwnd，直到cwnd 达到慢开始门限（ssthresh），停止慢开始算法，使用拥塞避免算法，拥塞避免算法思路是增长速率变为线性增长，也就是每经过一个往返时间RTT就把发送方的cwnd加1，所以综上：

当cwnd < ssthresh ，使用慢开始算法；
当cwnd = ssthresh，可以使用慢开始算法，也可以使用拥塞算法；
当cwnd > ssthresh，使用拥塞算法；

2、快重传和快恢复
通过上面两个算法可以使得网络传输速率一直增大，直到出现超时，这时候需要将cwnd重新调整到1个字节开始，使用慢开始算法，同时需要将慢开始门限ssthresh调整为cwnd（超时点）的一半，继续执行慢开始、拥塞避免算法。如果收到3-ACK（发送方一连接收到3个对同一个报文段的重复确认），这种可能的情况是，并不是发生了拥塞，可能是报文丢失，所以发送方不执行慢开始算法，直接使用快重传算法，立即发送缺失的报文段。同时执行快恢复算法，将门限值（ssthresh）调整为此时cwnd的一半，并执行拥塞避免算法。

作者：chen_yongzu
链接：https://www.jianshu.com/p/143ac8684fd6
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## 4.数据结构

#### 1.快速排序的思想

#### 2.红黑树的思想



## 5.计算机图形学

#### 1.渲染管线





# 6.Unity

#### 1.unity回调执行顺序



![img](https://img-blog.csdn.net/20160908194431877)



#### 2.Animator和Animation

两者都是控制动画播放的

Animation控制一个动画播放的各类方法和数据（当然你可以通过修改目标动画进行动画切换）

Animator则可以实现控制多个动画的播放，切换，叠加等一级对骨骼动画控制等更复杂的效果，是一个动画状态机



#### 3.对象池



#### 4.c# GC



# 7.操作系统

> 来自https://zhuanlan.zhihu.com/p/57910159

#### 1.线程，和进程的区别

一个进程可以有多个线程，进程是根本， 进程像火车，线程就是车厢。为了提高效率

#### 2.线程的调度

先来先服务，最短作业优先，时间片轮转法，优先级算法,高响应比算法。

#### 3.操作系统内存管理了解吗



#### 4.内存调度不够了怎么办

操作系统处理看能否释放内存，内存会用完吗，提到了虚拟内存机制内存置换机制。

#### 6.操作系统进程调度，银行家算法了解吗

连接https://blog.csdn.net/qq_34902437/article/details/82936161

#### 7.多线程编程了解吗

了解c++11标准的多线程，简单描述了下互斥量之类的。