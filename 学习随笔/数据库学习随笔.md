数据库学习随笔

#### 1.一条SQL语句执行很慢的原因

1. 偶尔很慢
   - 数据库更新数据是先存到redo log日志中去，然后等空闲转到内存中，但是redo log是有大小限制的，如果此时已经满了，就会停下其他工作，先读进去
   - 要访问的地方被加了锁，需要锁解除之后才能读
2. 一直很慢
   - 没有用到索引![image-20200820094125848](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20200820094125848.png)
   - 没有索引

#### 2.主键索引和非主键索引

​	主键索引的索引表存放的数据是整行的值，非主键索引的索引表存放的是主键的值

​	所以非主键索引查找，是查找到主键的值，在对主键的值进行查找，查找了两次



#### 3.ACID

原子性：一条事务要么全部成功，要么全部回退

一致性：事务的开始和结束执行保持一致，如果一个事务执行到一半，一些数据已经写入数据库说明不一致。

隔离性：一个事务的操作，不会被其他操作所干扰。有四种隔离级别，分别是：未授权读取，授权读取，可重复读取和串行化

持久性：一旦提交成功，永久有效



#### 4.B树和B+树

​	B+树是B树的变种，也是红黑树的变种。B树和红黑树的区别是，每一层能保存更多的数据（B树无红黑区分），结果就是B树高度变矮，可以减少硬盘与内存的IO置换次数，能加快速度。

​	B树和B+树的区别是，B+树存储数据都是在叶子节点，并且相邻的叶子节点有指针相连接，这样就有了很多好处。一点是保留了红黑树的有序特性和B树的IO置换次数减少特性，又加入了它独有的可以访问相邻节点的特性，我们有时候需要访问100~400的所有节点，那么就不用每次都去查找，而是找到100之后直接访问相邻节点即可。提高了效率



#### 5.数据库隔离级别

在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同，分别是：未授权读取，授权读取，可重复读取和串行化

1、读未提交（Read Uncommited），该隔离级别允许脏读取，其隔离级别最低；比如事务A和事务B同时进行，事务A在整个执行阶段，会将某数据的值从1开始一直加到10，然后进行事务提交，此时，事务B能够看到这个数据项在事务A操作过程中的所有中间值（如1变成2，2变成3等），而对这一系列的中间值的读取就是未授权读取

2、授权读取也称为已提交读（Read Commited），授权读取只允许获取已经提交的数据。比如事务A和事务B同时进行，事务A进行+1操作，此时，事务B无法看到这个数据项在事务A操作过程中的所有中间值，只能看到最终的10。另外，如果说有一个事务C，和事务A进行非常类似的操作，只是事务C是将数据项从10加到20，此时事务B也同样可以读取到20，即授权读取允许不可重复读取。

3、可重复读（Repeatable Read)

就是保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的，因此该事务级别禁止不可重复读取和脏读取，但是有可能出现幻影数据。所谓幻影数据，就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。在上面的例子中，可重复读取隔离级别能够保证事务B在第一次事务操作过程中，始终对数据项读取到1，但是在下一次事务操作中，即使事务B（注意，事务名字虽然相同，但是指的是另一个事务操作）采用同样的查询方式，就可能读取到10或20；

4、串行化  

是最严格的事务隔离级别，它要求所有事务被串行执行，即事务只能一个接一个的进行处理，不能并发执行。



#### 6.数据库三大范式

1. **第一范式：确保每列保持原子性**
   - 数据库中的所有字段都是不可分的，要根据实际需求决定，比如有个地址（省区），又要分别用省，区就不行。就要分成省和区两个
2. **第二范式：确保表中的每列都和主键相关**
   - ![image-20200820100415144](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20200820100415144.png)

3. **第三范式：确保每列都和主键直接相关，而不是间接相关**

   - ![image-20200820100501252](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20200820100501252.png)