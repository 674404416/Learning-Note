#### 数组与链表的区别

​	1.数组是连续的空间 支持随机读取 方便查找 数组必须提前设置好长度 分配空间时 需要一次分配够 不然只能重新分配一个更大的空间 把原来的复制进去 不好删和插入

​	2.链表不是连续的空间 只支持顺序读取 方便插入和删除 链表不用提前设置好长度



数组产生在栈中，链表产生在堆中



#### static关键字

​	用static关键字修饰的变量是静态的，从程序的产生到结束只初始化一次

​	如果变量是全局变量（函数) 变为静态全局变量 起作用范围只在本文件中 丢失了全局可见性

​	如果修饰的是类 则该类变成静态类 静态类的成员必须都为静态 不能被实例化 唯一

​	一般静态类是被用作工具类 因为在编译阶段就完成了 速度比较快 静态类不能被继承



​	除了静态类还有一个单例模式 较为相似 能被重写和继承



​	如果static修饰的是类里面的 说明是全局变量 其大小存储在全局变量区



#### 为什么析构函数可以是虚函数 构造函数不可以

​	虚函数是为了在不同的位置调用正确的函数 所以如果一个类有子类但是虚构函数不设置成虚函数，那么他的子类析构时，只调用父类的析构函数，就造成了内存泄漏。所以要把析构函数设置成虚函数。但如果一个类没有子类，设置虚函数反倒会降低效率，因为虚函数是设置一个虚函数表，会占用内存。 为什么构造函数不能呢，因为虚函数是对一个对象来说的，构造函数是构造这个对象，这个对象都没构造出来 当然没办法调用他自己的虚函数。



#### 五大内存区

​	全局区/静态变量区

​	栈区

​	堆区

​	常量区 1 2 3 a b c

​	代码区



#### const的位置

​	const有两个用法  左定值 右定向 const在*（指针左边） 只定值，在右边定向（地址）



#### extern"C"

​	程序按照c语言的方法来运行  c++有多态 所以对函数有编号 而c没有所以他们的编码方式不同



#### c++三大特性

​	多态：静态多态 重载  动态多态 重写 对应不同的状态执行正确的函数

​	继承：一个类可以继承于另一个类 免于重复的代码 共用共同的属性和方法

​	封装：封装之后可以只关心他的用法 不用关心其实现 类具有对数据的抽象性，隐藏性和封装性。



#### Vector扩容原理

1.5倍2倍扩容



#### map和set的区别以及实现

map的底层是红黑树 set的底层也是红黑树  都是自动排序的 

map存储的是Key-Value 键值对 不允许键重复  自动排序 map键不能修改值可以

set只有key 不允许出现键值重复 会自动排序 set不允许修改键值



​	**PS：键不能修改** 因为键是排序的基础 修改之后一是重平衡很复杂 第二不能保证是否重复



#### 初始化列表

​	并不是所有类里面的参数都能通过构造函数赋值，比如const和引用

​	需要通过初始化列表来初始化

 

​	因为const和引用 是需要绑定到对象的 所以定义时（分配内存地址）必须有初始值对象



  定义一般变量时：

  声明：声明变量类型和名字 -> 定义：根据类型分配内存地址空间 -> 初始化：将初始值拷贝到变量的    内存地址空间中（三步）

  因此变量的声明，定义和初始化可以分开，不需要一次完成

  定义引用类型时：

  将引用绑定到初始化对象（一步）

  因此定义引用类型时必须有初始值对象（必须为左值）

​	

#### 数组指针和指针数组

​	数组指针是指针 该指针指向一个数组

​	指针数组是数组  该数组存的是指针

```c++
int *a[10];//指针数组
int (*b)[10];//数组指针
```



#### 函数指针和指针函数

​	函数指针 是一个指针指向函数

​	指针函数是一个函数返回一个指针



#### 引用和指针的区别

​	引用必须初始化 指针可以只声明 不定义

​	引用就是对象的别名  指针是存的地址

​	引用的大小是实际的大小  指针的大小是4个字节（地址的大小）

​	引用不能中途修改引用的对象  指针可以指向其他的对象

​	引用和指针的++意义不一样

​	有const指针 没有const引用（因为引用不可修改）

​	

#### class和struct

​	基本一致 struct默认public 

​	class默认private



#### 堆和栈的区别

​	栈存放计算机自己释放的变量 在高地址 由高向低 空间小 一般为1mb

​	堆存放程序员new的变量 需要自己手动释放不然会造成内存泄漏 在低地址由低向高 堆内容量比较大4gb

​	栈因为是电脑控制的 所以效率比较高 而且栈是先进先出 严格按照这个执行 所以不会有从中间退出的情况没有碎片

​	堆有可能要从中间退出 所以会产生碎片 最后因为堆要搜索空间 有没有可用空间 申请空间 所以效率低

​	但是堆比栈更灵活 





#### java/c#是如何实现跨平台的

​	java的底层是虚拟机 编译完之后是编译成一种中间语言 然后虚拟机（程序）根据不同的机器 生成本地代码



#### c#值类型和引用类型

​	**值类型** 存储的就是 **数据** 就是 **值**

​		有 byte,short,int,long,float,double,decimal,char,bool,struct

![image-20200807095921406](C:\Users\sunhaojun\AppData\Roaming\Typora\typora-user-images\image-20200807095921406.png)

​	**引用类型** 存储的是数据的引用

​		有class,string，接口，委托，数组都是引用类型

​							![image-20200807100037295](C:\Users\sunhaojun\AppData\Roaming\Typora\typora-user-images\image-20200807100037295.png)

​		当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时**并没有为其分配堆上的内存空间**。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。

​		

​		声明在栈上分配一个地址空间，new时把堆上的地址传给栈上的空间





​	值类型在栈上，引用类型在堆上。但并不是值类型只能在栈上

规律是：

- 引用类型部署在托管堆上；
- 值类型总是分配在它声明的地方：作为字段时，跟随其所属的变量（实例）存储（比如int数组就全部在堆上）；作为局部变量时（类中），存储在栈上。





相同点：

引用类型可以实现接口，值类型当中的结构体也可以实现接口；

引用类型和值类型都继承自System. Object类。



区别

**1）范围方面**
C#的值类型包括：结构体（数值类型、bool型、用户定义的结构体），枚举，可空类型。
C#的引用类型包括：数组，用户定义的类、接口、委托，object，字符串。



**2）内存分配方面：**

数组的元素不管是引用类型还是值类型，都存储在托管堆上。

引用类型在栈中存储一个引用，其实际的存储位置位于托管堆。简称引用类型部署在托管推上。而值类型总是分配在它声明的地方：作为字段时，跟随其所属的变量（实 例）存储；作为局部变量时，存储在栈上。（栈的内存是自动释放的，堆内存是.NET中会由GC来自动释放）

**3）适用场合**

值类型在内存管理方面具有更好的效率，并且不支持多态，适合用做存储数据的载体；引用类型支持多态，适合用于定义应用程序的行为。

- 引用类型可以派生出新的类型，而值类型不能，因为所有的值类型都是密封（seal）的；
- 引用类型可以包含null值，值类型不能（可空类型功能允许将 null 赋给值类型，如  int? a = null;  ）；
- 引用类型变量的赋值只复制对对象的引用，而不复制对象本身。而将一个值类型变量赋给另一个值类型变量时，将复制包含的值。





#### c#拆箱和装箱

​	装箱是 值类型 转换为 引用类型    装箱是隐式转换

​	拆箱是 引用类型 转换为 值类型	拆箱需要显式转换



​	**装箱和拆箱的优缺点**

​	优点是满足类型转换 缺点是装箱时要new一个对象，数据量大时非常影响效率 造成性能损失

​	要避免频繁的装箱



#### c#/.NET垃圾回收

当new时，程序执行了什么 

- 计算新建对象所需要的内存空间
- 检查托管堆，看看是否有足够的空间
  - 有足够的空间，调用构造函数，将对象地址放在NextObjPtr中
  - 没有足够的空间，执行垃圾回收机制，清理托管堆，仍不够 扔出OutofMemoryException
- 成功之后 移动NextObjPtr指向下一个可用地址，然后将对象引用返回给调用者

![image-20200807113746228](C:\Users\sunhaojun\AppData\Roaming\Typora\typora-user-images\image-20200807113746228.png)![image-20200807113753125](C:\Users\sunhaojun\AppData\Roaming\Typora\typora-user-images\image-20200807113753125.png)





#### UNION联合体

​	用来测试大小端，同时只能有一个值正常 空间大小是大的



#### new/delete 和 malloc/free的区别

​	new在自由存储区 malloc在堆区  **自由存储区和堆区概念不一样**自由存储区是抽象的概念 堆是实际存在的内存区域 new是否是堆 要看如何实现的 自由存储区既可以是堆也可以是静态的

​	new/delete 不需要参数 malloc/free需要声明的空间大小

​	new/delete 返回的是定义的指针  malloc/free返回的是空指针

​	new/delete是运算符重载  malloc/free是函数

​	new会进行构造函数 malloc不会

​	new/delete失败时 抛出异常  malloc/free失败时返回NULL

​	new没有直观的函数进行扩容 malloc可以通过realloc扩容



#### c++关键字

​	预定义的，在语言和编译系统中具有特殊含义的词

​	比如if else while throw union this int virtual



#### 面向对象和面向过程的区别

​	面向对象是对对象进行操作，对象有什么属性，对象能做什么事

​	面向过程是一个过程传入做这个过程的对象 然后过程里面指导对象做事



#### 继承

​	一个类可以通过继承另一个类获得另一个类的属性和方法 避免代码重复 共用共同的属性和方法



#### 多态

​	静态多态：重载 函数名相同 参数个数或者参数类型 不同 可以实现重载  返回类型不同也可以 但是没啥用

​	动态多态：通过virtual声明一个函数是虚函数(=0说明是纯虚函数)  子类继承的时候就可以重写虚函数  虚函数是为了让函数在正确的位置调用正确的函数 

​	对于动态多态，一般来说其子类会有一个地址（在最开头）储存虚函数表 虚函数表是链接的虚函数的地址 所以有一个虚函数 类的大小就会大4



#### c++成员函数在内存中的存储方式

​	用一段空间来存放共同的函数代码段来节省内存。C++编译系统正是这样做的，**因此每个对象所占用的存储空间只是该对象的数据部分（虚函数指针和虚基类指针也属于数据部分）所占用的存储空间，而不包括函数代码所占用的存储空间**。



#### C++内存管理

五个区域

​	全局/静态区域

​	栈区

​	堆区

​	常量区

​	代码区



​	new的是自由存储区 自由存储区不是实际存在的概念 而是一个虚构的概念 可以使静态区也可以是堆区看具体实现



#### 内存对齐

​	一个类按照最大的字节大小对齐 结尾的空间必须是他的整数倍 除此之外 在类中也要对齐



#### C++11新特性

- auto关键字 自动推算类型
- lambda表达式 匿名函数 适合只使用一次的短的函数
- foreach 范围内for
- 智能指针 四种指针
- nullptr 空引用 null的值是0 传参会出现问题
- forward_list 前向链表
- array 数组容器
- 右值引用  可以引用右值





#### 智能指针

指针不用的时候会自动释放节省空间，防止内存泄露

1. unique_ptr 只允许基础指针有一个所有者
2. shared_ptr可以有多个所有者
3. weak_ptr 配合shared使用，防止互相引用 造成内存泄漏



#### 类型转换（四种

​	为了更清晰的进行显式转换

1. const_cast  const转换 常量指针和引用被转换成非常量指针和引用，并仍指向原来的对象
2. static_cast  和c语言风格强制转换基本一样 但是没有安全检查 所以有安全隐患  用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性需要开发者来维护
3. dynamic_cast
4. reinterpret_cast